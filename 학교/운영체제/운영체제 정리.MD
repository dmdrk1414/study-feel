## chapter 2. Operating System

#### p 2. 운영체제 시스템 : 어플 과 하드웨어의 중간 다리역활

---

#### p 3. 운영체제의 목적

1. 효율성 : 자원에 대한 효율성
2. 발전성 : 기본 베이스 제공

---

#### p 5. - 6 운영체제의 편리성 : 편리성을 주는 기능들 1 - 6;

1. Program development
2. Program execution
3. Access to I/O devices
4. Controlled access to files
5. System access
6. Accounting
7. Error detection and response



1. 프로그램 계발을 해준다 
2. 프로그램 실행과정, 자원관리, 스케줄링 
3. 복잡한 내부 숨기고 함수만 호출 (I/O devices 접근)
4. 여러 장치, 사용자 동시 접근(파일 동시 접근)
5. 다중사용자(자원보호, 동시성): 동일한 시스템
6. 회계기능 : 매래 각디바이스 성능 향상 (성능 개선의 여지)
7. 에러 검출 알려주는 기능 : 블루 스크린, 덧셈 뺏셈, 0으로 나눔,메모리 할당 금지

---

#### p 7. 자원의 효율적 사용

1. Resources 컴퓨터의 자원 -> 메모리 컴팩션 ( 효율적 관리 )
2. Responsible for managing resources 자원의 책임
3. Functions in the same way 함수들의 집합 Collective of Fuc

---

#### p 8.  컴퓨터의 전체적인 사진.

<img src="I:\Documents\Desktop\운영체제\1@attach_221006_183716_938.jpg" style="zoom:40%;" />

---

#### p 9. 

- OS의 이점 발전성 (컴퓨터의 발전이 쉽게이뤄진다)
- 발전성 -> 고치면서 커진다.
- 새로운 하드 -> 새로운 기능
- 패치 프로그램 기존 운영 체제 모듈중 에러가 있는 모듈 제거 -> 새로운 모듈 삽입

---

#### p 10. Operating System

운영체제의구성 OS = Kernel + System Programs

---

#### p 11. Kernel 커널

커널  

- 거대한 API 함수 관련 함수들의 집합
- 거대한 API 함수 관련 함수들의 집합
  - 프로그램 호출 실행
  - 디바이스(네트워크, USB카드 드라이버, 타이머)
  - 데이타 -> 하드웨어 -> CPU -> 디바이스 드라이버

함수들을 크게 나누어 보면 

- Process관리, 스케줄링, 실 기억장치, I/O device 드라이브

- kernel 함수들이 호출되는가?

  - 응용프로그램에서 API 함수를 호출할 경우
  - I/O (CPU에서 전기적) 장치에서 데이터가 들어올 경우 

  ---

#### p 13. Multiprogramming Systems

멀티 프로그래밍

1. I/O 함수 실행시 A -> B
2. I/O 장치에 데이터가 들어 올때 A -> B 우선순위에 따라 다르다
3. 현제 프로그램 종료 A -> B
4. 시분할 처리 기능 X



- 여러 프로그램을 동시에 실행시킴

- CPU는 언제  다른 프로그램에게 넘기는가?  A -> B -> c 

  - 실행중 A 프로그램 ->  I/O함수 (scanf) 호출할때 (장치에 데이터가 없을때) -> A -> B
  - I/O 장치에 A가 데이터가 들어오면 Ready상태가 된다. ( 우선순위에 따라 A실행 상태 여부확인가능)
  - 현재 실행중 프로그램이 종료 OR I/O 장치로 인해 대기중이면 다른 프로그램에 CPU 넘어감

- 시분할 처리 기능 없음

  ---

#### p 19. Time Sharing System 시분할 시스템

1. CPU가 일정시간 동안 번가라 실행

   1. 현제 실행 프로그램이 I/O함수 호출할때
   2. I/O 데이터 받을때
   3. 0.1초식 번가라 사용 (쉐어링)

   

1. CPU가 각 프로그램을 일정시간동안 번갈아 가면서 실행
2. 언제 CPU를 다른 프로그램에 넘기는다
   1. I/O함수 호출
   2. I/O장치에 데이터가 들어올때
   3. 현제 실행중 프로그램 0.1초동안 I/O없이 실행할때 쉐어링

---

#### p 20. Multiprogramming vs Time Sharing

|         ---         | Batch Multiprogramming 멀티 프로그래밍 |    Time Sharing 타임 쉐어링     |
| :-----------------: | :------------------------------------: | :-----------------------------: |
| Principal objective |     Maximize processor use 이용률      | Minimize response time 반응시간 |
|      반응시간       |                  낮다                  |              높다               |
|       이용률        |                  높다                  |              낮다               |

- CPU 이용률 : CPU가 총실행한 시간 중 프로그램 실행시간

  - **사용자 프로그램실행(7초)** + [ CPU스위칭(0.6초) + IO스위칭(0.4초) ] + CPU휴식상태(2초)

    ​							                                  CPU 시간 버림                              정기적 신호가 올때 까지 for문 반복

    - CPU 이용률은 0.7 = 7초 / 10초

- 응답시간(response time) : 입력이후 첫 출력이 나오는 시간
  1. 키보드에서 입력후 , 처음으로 화면에 출력이 나오는 시간
  2. Internet 에서 주로 입력후 웹페이지가 화면에 보여지는 데 걸린 시간
  3. 프로그램의 응답시간 ex) 프린터의 시간.

---

p 22. Multi & Time 시간 계산

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221006224254161.png" alt="image-20221006224254161" style="zoom:70%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221006224123535.png" alt="image-20221006224123535" style="zoom:70%;" />

- 멀티 프로그램
  - ( 1초 * 9개 프로그램 ) + 0.1초 = 9.1초 이후 내꺼 프로그램 response 시간
- 타임 쉐어링
  - (0.1초 * 9개 프로그램) + 0.1초 = 1초 이후 내꺼 response time

---

#### p. 23 멀티프로그램 vs 타임 쉐어링 CPU 이용율 비교

- 타임 쉐어링   **이용율 낮음 VS 응답율 높음**

  - 0.1 마다 프로그램 번가라 실행

  - 이용율 = 사용자프로그램실행(10초) + CPU스위칭(0.4초) + IO스위칭(0.1초)

    CPU 이용률은 0.95 = 10초 / 총 10.5초			95%
    
    

- 멀티 프로그램   **이용율 높음 VS 응답율 낮음**

  - I/O작업이 아니면 계속 진행

  - 이용율 = 사용자프로그램실행(10초) + IO스위칭(0.1초)

    CPU 이용률은 0.99 = 10초 / 총 10.1초             99%

---

#  chapter 3. Process Description and Control

#### p. 2 현제 돌고있는 프로그램

#### p. 3 Process 생성법

1. Interactive logon : 로그인 할때
2. 기존에 실행된 Process에 의해서 = 기존에 실행된 Process에의해서 PS 실행

#### p. 4 Process Termination 프로그램 종료

1. Normal completion : Main 함수 리턴, EXIT 함수 Call.

2. Bounds violation : 포인터 실패 할때 / 경계 위반하는 경우 / Pointer 참조 실패.

3. Arithmetic error : 수학적 오류, 계산, '0'으로 나눌때.

4. Invalid instruction : 잘못된 명령어, 실행 파일 다운 -> 중간 실패 -> 실행파일 짤린다.

5. Parent termination : 부모 프로그램 종료 -> 자식 죽는다.

---

#### p. 6 Process Control Block (PCB)

PCB: 운영체제 내에서 관리 되는 프로세스 구조체 -> 프로그램의 정보

- 커널에 하나의 프로세스를 관리하는데 필요한 정보 보간

현제 돌고 있는 PS의 정보

- 시간

- 현제 돌고 있는 프로그램의 구조체
- 정보들을 가지는 Id

---

#### p. 7 process 구조체

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221006235556854.png" alt="image-20221006235556854" style="zoom:67%;" />

---

#### p. 8 Trace of Process

Dispatcher : 다른 프로그램으로 넘겨주는 것

Scheduler : Kernel 내의 하나의 함수 이름

- process중 우선순위가 가장 높은 프로세스 고른다.
- process에게 processor(CPU)를 넘겨주는 것.
- Scheduling 알고리즘 : 우선순위가 높은것 고른다.

---

p. 9 스케쥴러 Example

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007000101808.png" alt="image-20221007000101808" style="zoom:67%;" />

Program Counter : CPU가 실행할 다음 명령어 주소를                                                  								  가지는 레지스터 이름

---

#### p. 11 Scheduler의 실행 상태

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007000430179.png" alt="image-20221007000430179" style="zoom:67%;" />

각 프로그램 종료후 Scheduler 실행

---

#### p. 12 Process States 프로그램 상태

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007081852461.png" alt="image-20221007081852461" style="zoom:67%;" />

- A -> Dispatcher -> B -> Dispatcher -> C -> Dispatcher -> A -> Dispatcher -> C
- 많이 기다리면 우선순위 높다.

---

#### p. 13 프로그램의 5가지 영역

 A Five-State Model

1. Running : processor에 의해 실행중 상태
2. Ready : processor만 주어지면 언제든 실행될 수 있는 상태
3. Blocked : I/O장치에서 대기(waiting) 상태

----

#### p. 14 언제 상태가 변하나?? (프로그램의 실행 순서)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007082313545.png" alt="image-20221007082313545" style="zoom:67%;" />

- 한글 -> Block -> "ㄱ" -> Read -> run -> ㄱ 출력 -> Block -> "ㅏ" -> Read -> run -> ㄱ지우고 ->  가 출력 -> Block -> "ㄱ" -> Read -> run -> 가지우고 -> 각 출력 -> Block -> 저장 -> Read -> run -> Buffer -> 디스크에 저장 -> Block
- 마우스 -> Block -> 옮긴다 -> Read -> run -> 위치 이동 -> Block(반복) 

---

#### p. 15 언제 Wait(Blocking) 사태가 되는가

| -Device        | Wait, I/O함수 호출할때 Blocked 상태                          | I/O intrerrupt 발생시 Ready State됨              | Interrupt 종류                          |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------ | --------------------------------------- |
| 마우스, 키보드 | scnaf() 호출할때, GetMessage()호출할때                       | 키보드에서 엔터, 마우스를 움직일때               | 키보드 마우스 Interrupt                 |
| Disk(파일읽기) | read(), fread(),fscanf()                                     | 디스크가 파일을 읽고, 메모리에 전달한 후         | Dist(or USB) interrupt                  |
| 네트워크       | receive() 호출                                               | 네트워크 보드에 데이터 도착                      | Network interrupt                       |
| Timer          | Sleep(2000), sleep(2)                                        | 지정시간 (2초)이 지난후,                         | Timer interrupt                         |
| Samaphore      | lock(s) 함수 호출 때: 자원혼자사용할려고 lock 호출했지만 누가 이미 lock한 경우 | 다른 PS가 unlock(s) 함수를 호출, Lock을 풀어줄때 | Interrupt와 무관, unlock(s)호출할 때만. |

---

#### p. 16 Running -> Blocked 상태로의 전환

I/O함수 호출 : scnaf(), read(), receive()등

- API 함수 호출 -> kernel 속으로 진입
- 키보드, 디스크, 네트워크 device에 도착한 데이터가 도착할때 까지 대기
- Running 상태에서 Blocked 상태로 설정
- Scheduler() 함수 호출 -> processor를 다른 PS에거 준다 -> PS는 중단되고(대기) -> 다른  PS가 실행
  - Scheduler()함수 
    - Ready살태의 PS들 중 우선순위가 높은 PS고르고
    - processor(CPU)를 그 PS에게 넘겨줌
    - 선택할 PS가없으면 Processor는 idle 상태(for(;;); 를 무한 Loop 돌면서 생하면서 대기함)
    - Blocked 상태의 PS은 스케줄링 대상 제외

---

#### p. 17 Blocked -> Ready 상태로의 전환

- Block에서 Ready상태로 변환되는 과정

- 디바이스는 데이터가 도착한 것을 processor에게 interrupt(전기적 신호가 감)를 통해 통보함

- Interrupt(timer, network, disk 등으로 부터)이 오면

  1. Processor는 현제 process의 실행을 Block으로 (Running -> Ready)

  2. 대기큐에서 방금 들어온 데이터를 기다리는 process를 찾아 데이터 전달

  3. 데이터를 받은 PS을 Blocked 상태에서 Ready 상태로 변환
  4. Ready상태의 PS가 하나 추가 되어서, (PS가 우선순위가 제일 높을 수 있다) -> Scheduler()함수 실행

- Scheduler()를 호출 (Interrupt의 마지막에 항상 scheduler 호출함)

  1. 우선순위가 높은 PS에게 CUP를 넘겨 줌
  2. 프로세스가 우선순위가 제일 높으면 깨어난 프로세스가 바로 실행, interrupt가 들어오기 전에 실행된 프로세스가 계속 실행됨

---

#### p. 18 Multiple Blocked Queues

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007204641712.png" alt="image-20221007204641712" style="zoom:67%;" />

장치에 따라서 대기큐가 다르다.

---

#### p. 19 구조체 정보를 Queue(Linked List)을 이용해 구현함

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007205107310.png" alt="image-20221007205107310" style="zoom:67%;" />

---

### p. 20 Ready Queue or Blocked Queue?

- Queue는 process 구조체들을 linked list로 관리
- Ready Queue
  - Ready 상태의 process 구조체들만 모아 둔 linked list로 구현된 큐
- Blocked(Waiting or Event) Queue
  - 키보드 대기큐, 디스크 대기큐, 네트웤큐, 다이머 대기큐, 메마포어 대기큐 등이 있음

---

#### p. 21 Suspended Processes

만약 (if) main 하나로 90개의 프로그램 관리한다면? -> block (메모리 잡아 먹는다)

- 모든 PS가 I/O를 대기하고, CPU(processor)는 idle(놀고있는 상태)
- 장시간 대기 상태 -> PS를 Disk의 별도의 swap영역으로 빼낸다.
- swap out : disk로 ps를 뺀다.   memory -> disk
- swap in : memory로 ps을 넣는다. disk -> memory
- swap out하면, process는 Blocked -> Suspend state로 변경.
- swap in 하면, process는 suspend state -> Ready state로 됨.

---

p. 22 One Suspend State

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007212039886.png" alt="image-20221007212039886" style="zoom:67%;" />

Swap in 하면 : Suspend -> Ready 

Swap out 하면 : Bolcked -> Suspend

---

#### p. 23 Process Structure : 

시험, PS가 메모리에 어떻게 저장되는가?, stack에 저장된건?, 이중 저장되어있는건?

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007212620102.png" alt="image-20221007212620102" style="zoom:67%;" />

Stack 

1. 함수의 매개변수, 지역변수
2. 함수가 리턴해야 할 주소다.

Heap

1. 동적으로 할당 받음 (new)키워드 생성

Data

1. BSS 초기화 되지 않는 전역변수 | Data:  초기화 된 전역변수

text(code)

1. 함수 코드들 변수들을 뺀 실행코드 영역

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007213252359.png" alt="image-20221007213252359" style="zoom:70%;" />

---

#### p. 24 Process image & Process Control Block

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007213423415.png" alt="image-20221007213423415" style="zoom:67%;" />

stack 

1. 지역변수, 함수의 리턴할 주소를 

비어있는 공간

1. stack or heap이 부족할때 사용한다.

heap

1. new, 말록, 동적 할당 메모리 영역.

uninitialized data

1. bss : 초기화 하지 않은 전역변수.

initialized data

1. data : 초기화 된 전역 변수.

text(code) 

1. 함수 코드들, 변수를 뺀 실행코드 영역.

exe 파일 영역 : initialized data + test(code)

---

#### p. 25 Process Control Block = Process Structure : PS의 정보를 저장하는 구조체

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007214112987.png" alt="image-20221007214112987" style="zoom:50%;" />

Process Structure라고도 함 : PS의 정보 저장하는 구조체

1. Process Identification : ID 저장
2. Processor State Information : CPU 부분 백업 받는 부분, 컨테스트 저장(일시정지할때)
3. Process Control : 우선순위 등등 스케줄링 부분에서 사용하는 정보.

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007214607588.png" alt="image-20221007214607588" style="zoom:50%;" />

---

#### p. 27 Process Control Block : 문맥(context) data 문맥 저장

Processor State Information : context(문맥) data 문맥을 저장한다.

- context : CPU의 중간에 일시정지된 CPU를 저장하는 곳 | 
  - 실행중인 프로세스가 일시 중지 ->  processor의 registers(context data)전부를 백업하는 곳
  - 재실행 하면 -> 백업된 context data를 다시 CPU 내부로 download해야함                                          (memory -> processor registers)
- General Working Registers (R1, R2, R3)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007215800878.png" alt="image-20221007215800878" style="zoom:50%;" />

if 실행하는 중간이 0.1초 가 끝나면?

- Process Control Block에 저장한다. -> context(문맥) data registers(context data)

---

#### p. 30 Process Control Block가 어떻게 CPU 레지스터를 저장하는가.

Processor State Information : context data(저장소)

- processor의 registers(context data)의 SP(stack point)
  - processor의 registers(context data)마다 SP가 있다.
  - SP는 
    1. function parameters, 함수 매개변수
    2. local variables 지역 변수
    3. address to return 리턴 값 

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007221018275.png" alt="image-20221007221018275" style="zoom:50%;" />

---

#### p. 31 Process Control Block : 안의 상세 정보

Process Control Information Ready 큐에서 기다리는 시간. 메모리를 실행하는 시간.

Process state : 프로그램의 상태 정보를 저장한다.

Priority : 우선 순의.

Scheduling-related information : waiting, amount of time that the process

Event: event 의 정보를 저장한다.

---

#### p. 32 Process Control Block :  PCB의 주된 기능

- A process may be linked : 다양한 링크드 리스트 저장
- ready or waiting queue : 상태저장
- parent-child (creator-created) relationship : 부모 자식관계

---

#### p. 33 

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007224812514.png" alt="image-20221007224812514" style="zoom:67%;" />



---

#### p. 34 Process Control Block : 프로그램의 Main memory가 어디에 있는가?

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007224515912.png" alt="image-20221007224515912" style="zoom:67%;" />

- 프로그램의 pointers to segment and/or page tables
  - pointers to structures of opened files, sockets, or windows(각각윈도우의 정보)
  - 파일 열때 정보 구조체 (ReadOnly, WriteOnly)

---

#### p. 35 Modes of Execution   Kernel(커널) 모드 설명

- User mode
  - cpu제어를 할수 없다, 명령어가 매우 다르다.
- System mode, control mode, or kernel mode
  - CPU 제어 모드 가능
  - 운영체제 모드
  - Kernel mode에서 사용가능 하다.
    - API 함수를 호출하여 커널로 진입할 때
    - device driver 내의 interrupt handler를 실행할 때

사용자 프로그램 -> intrupt -> CPU 멈추고 -> interrupt handler 실행 (device driver)

​																			 사용자모드 -> 커널모드

---

#### p. 37 인터럽트 발생 시의 처리 과정 : 사용자 모드 => 커널 모드

- Mode switch ( user mode => Kernel mode로 switch)

  - I/O device 또는 timer에서 interrupt 발생
    - 인터럽트처리함수(ISR) 시작주소로 JUMP함 (벡터링 : 인트럽이 들어온 드라이버 저장)
    - PS의 문맥(registers)을 PCB에 저장 (문맥 저장)
  - Interrupt handler (interrupt service routine: ISR)
    - ISR(Device Drive 함수)의 고유기능 실행
  - Scheduler() 함수 호출: 모든 ISR의 마지막엔 항상 이함수 호출함.

  <img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007232030660.png" alt="image-20221007232030660" style="zoom:67%;" />

---

#### p. 38 인터럽트 발생 시의 처리 과정

![image-20221007232402232](C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007232402232.png)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007232352215.png" alt="image-20221007232352215" style="zoom:67%;" />

![image-20221007232419616](C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007232419616.png)

1. 인터럽트 요청 
2. 실행중단
3. 벡터링 : 비바이스 드라이버 주소 찾기 
4. 문맥저장 : Processor Control block에 저장한다. 
5. 커널에 통보
6. 고유업무 수행
   1. 도착한 데이터를 기다리는 => 프로세스를 대기 큐에서 찾음
   2. 데이터를 그 프로세스에 전달
   3. PS를 Blocked -> Ready 상태 전환
   4. scheduler() 호출 ( 우선순위를 확인해서 준다. ) **무조건 Interrupt 이후 scheduler()호출**

- Scheduler()가 실행된 구간. **무조건 우선순위로 PS에 CPU가 할당된다. (Scheduler알고리즘에 의해 )**

|                              | 무조건 Interrupt 이후 scheduler()호출                        |
| ---------------------------- | ------------------------------------------------------------ |
| Scheduler 스케쥴러 실행 구간 | 7. Scheduler()실행 : 기존  프로세스 선택 ( 기존 실행 프로세스가 여전히 최우선 순위일 경우 ) |
| Scheduler 스케쥴러 실행 구간 | 8. 문맥 복구 : 컨트롤 복구 -> CPU 문맥 복구                  |
| Scheduler 스케쥴러 실행 구간 | 9. 인터럽트 복귀 명령                                        |

- 우선순위가 높은순

|                              | 무조건 Interrupt 이후 scheduler()호출                        |
| ---------------------------- | ------------------------------------------------------------ |
| Scheduler 스케쥴러 실행 구간 | 7. Scheduler()실행 : 기존  프로세스 선택 ( 기존 실행 프로세스가 여전히 최우선 순위일 경우 ) |
| Scheduler 스케쥴러 실행 구간 | 8. 문맥 복구 : 컨트롤 복구 -> CPU 문맥 복구                  |
| Scheduler 스케쥴러 실행 구간 | 9. 인터럽트 복귀 명령                                        |

---

#### p. 39 Process Switch : PS_A -> PS_B 로 프로그램 스위치 작업

- 스위치 과정
  - Proceess p1 실행중 -> interrupt 발생 -> ISP(인터럽트 처리함수)에서 기능 실행 -> scheduler() 호출 -> process p2 실행
  - Process p1 실행 중 -> I/O 함수 호출 -> I/O 장치에 데이터가 없음 -> blocked 상태 (대기) -> scheduler() 호출 -> Process p2 실행

----

#### p. 40 Process Switch가 발생하는가?

- Clock(timer) interrupt
  - Time sharing system -> thime slice(0.1초)를 다 사용한 경우
- I/O interrupt (키보드, 디스크, USB, 네트워크 장치)
  - 창치 (dvice) 에서 기다리던 데이터가 도착한 경우
- I/O 함수 호출
  - 실행되던 프로세스가 아래의 API 함수를 호출했는데
    - scnaf( 키보드 ), fread( 파일 ), recv( 네트워크 ), sleep( timer )
    - 해당 장치에 데이터가 없을 경우 함수를 호출한 PS는 blocked된 -> scheduler()호출

---

#### p. 41 Process Switch가 언제 발생하는가?

- Trap interrupt(에러 발생 시 해당 자치가 발생시킴)

  - Segment fault(pointer 변수가 잘못되었을 때; memory 장치)

  - Illegal instructions( 명령어가 깨졌을 때, CPU )

    -> Exit state 프로그램 종료

- Memory fault interrupt (메모리 장치에 의한.)

  - 가상 기억 장치에선 -> 일부만 메모리에 로드 프로그램을 실행가능
  - **실행중 PS**에서  -> 다음 실행할 **명령어 또는 변수 없을때** -> **memory fault 발생**
  - 디스크에 다음 명령어가 -> 블록을 읽도록 지시한 후 -> **현제 PS는 Blocked state**로 대기시킴 -> scheduler() 호출
  - 디스크가 읽어 주면 -> **디스크 interrupt 발생** -> 디스크 interrupt의 마지막 **scheduler()** 호출 -> 프로그램 재실행

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008004645269.png" alt="image-20221008004645269" style="zoom:67%;" />

---

#### p. 42 언제 Process Switch가 발생하는가? - 그림

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008005441652.png" alt="image-20221008005441652" style="zoom:80%;" />

MMU 장치에서는 실제 메모리 주소를 건들수 있다. 

---

#### p.43 실행 중지된 프로세스의 재 실행 위치는? : I/O 함수 콜 할때

- I/O 함수를 호출할 때

  1. 네트워크 보드에 받을 데이터 없으면 대기

  2. 실행중인인 프로세스 Running -> Blocked 상태로 변경

  3. 프로세스 구조체를 -> 네트워크 대기 큐(Qeuee)로 이동

  4. Processor의 모든 registers를 -> 스택에 저장(문맥저장)

  5. Scheduler()함수 호출; 

  <img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008015642514.png" alt="image-20221008015642514" style="zoom:67%;" />

  6. scheduler()에서 리턴 -> 도착한 데이터 -> I/O 함수인 recv()함수에서 리턴.

  ~~ㅁㄴㅇ~~

  

  **인트럽은 전기적 신호 => CPU점프 => 스케쥴링**

---

#### p. 44 실행 중지된 프로세스의 재 실행 위치는? : Interrupt

- Interrupt가 발생할 때
  1. Process p1 실행 중 -> interrupt 발생 -> ISR(인터럽트처리함수)(p.37참고)    -> ISR이 scheduler() 호출 -> process p2로 CPU넘어감
  2. **이 경우 인터럽트 전에 실행되던 P1은 어떻게 되는가?**
     - p1은 ready큐로
     - p1이 재실행되면 -> 인터럽트 전에 **마지막으로 실행했던                                                             명령어**의 그**다음 명령어부터 실행됨**

---

# chapter 4. Threads



#### p. 7

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008021939074.png" alt="image-20221008021939074" style="zoom:50%;" />

코드는 그냥 보기면

- Thread

  - Thread간에 통신을 가능 => Count을 이용해

  - 전역 변수를 이용한

- Program
  - Program 간에 CPU간의 통신이 힘들다.

---

#### p. 10 Process(Thread를 지원하는 OS)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008022717884.png" alt="image-20221008022717884" style="zoom:60%;" />

Process ( Thread를 관리하는 )의 역활

1. 자원의 소유주 역할( 자원 할당 대상 ).
2. 메모리 보호 대상.

---

####  p. 11 Tread

1. 스케줄링 대상
2. Processor가 실행하는 대상
3. **Each thread has 각각의 쓰레드는 이런기능을 가진다.**
   1. state : Running, Ready, Blocked
   2. thread context : 백업된 processor registers
   3. Priority : 우선순위

---

#### p. 12 Thread 생성

- Thread 생성
  1. 일반적인 스레드 함수 -> for() loop을 돈다.
  2. loop를 돌지 않고 한번만 작업 가능(이미지/애니메이션 다운받아 디스플레이)
- 기존의 main() thread에서 thread를 생성하는 API 함수를 호출 : **누가? -> 프로그래머가 직접**
  - 함수 호출시 =>thread 시작함수를 지정
  - 스레드는 => 스레드 시작함수에서 실행
  - **main() thread**는 주로 GUI의 입력 및 출력 담당
    - 키보드, 마우스의 입력을 받아 화면에 출력
    - c프로그램의 main() 함수

---

#### p. 13 Thread 종료 Thread의 종료 방법

- Thread 종료
  1. Thread의 시작 함수에서 리턴하면 종료
  2. main(), WinMain()에서 리턴하면 자동 종료
  3. Java 윈도우 프로그램 => main()에서 리턴해도 => 내부 **event dispatch thread** 계속 실행함
     - 윈도우 창에서 종료 버튼 눌러야 종료

---

#### p14. Single Thread

- main() 함수 하나만 있을때 

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008025148904.png" alt="image-20221008025148904" style="zoom:67%;" />

---

#### p. 15 Multi-Threads의 이점

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008025825803.png" alt="image-20221008025825803" style="zoom:67%;" />

Multi-Threads의 이점은 **시간을 줄이는 것이다.**

---



<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008025933079.png" alt="image-20221008025933079" style="zoom:67%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008031501339.png" alt="image-20221008031501339" style="zoom:30%;" />

| 순서 Ready                     | Running | Block                                                        | Ready/Running                                               | 모든건 우선                     | 순위                      |
| ------------------------------ | ------- | ------------------------------------------------------------ | ----------------------------------------------------------- | ------------------------------- | ------------------------- |
| Thread A           (Process 1) | Running | Blocked                                        (I/O 함수 만남) | ready                               (데이터 들어옴)         | running                         | ready                     |
| Thread B           (Process 1) | Ready   | Running                                     (우선순위 높음)  | Running                                     (우선순위 높음) | ready                           | ready                     |
| Thread C           (Process 2) |         |                                                              |                                                             | read               (PS created) | Running   (우선순위 높음) |



---

#### p. 17 기본 PS에 비해 Thread의 우수성

- 생성시간 단축
- 종료 시간 단축
- thread간 CPU switch 시간 단축
  - **메모리 보호의 공간 새로설정 XXX**
    - thread간 **Switch 시간 빠르다**
- 전역 변수를 통한 데이터 공유 => thread간 통신 속도 향상

---

#### p. 18 Thread 사용 이점 -1 : Thread 작업 종류

- Foreground(Main 쓰레드) and Background work(Thread)으로 나누어 프로그래밍
  - Foreground작업 : main 스레드
    - 마우스, 키보드, 메뉴, 버튼 입력 : 사용자 이벤트 처리 작업
    - 인터넷 여러 이미지를 보여주는 작업
  - Background작업 : 스레드 담당
    - 화면 redraw 스레드
    - 일반 service 스레드
- **Asynchronous processing( 비동기 처리 )**  동시처리 기능 <--> 동기 : 기다리면서 주고받는다
  - 같은 작업을 같이 처리 하는것

10명이 같은 일을 분할해서 한다 <===> 한명이 10개의 일을 절차적으로 해결한다.

---

#### p. 19 Thread 사용 이점_2 

- 실행 속도 향상
  - 동일한 작업을 동시에 여러개 처리.
  - 서버 
    - Client에게 받은 request를 처리하고 결과 전송
    - 여러 스레드가 동일 service 함수 호출
  - 인터넷에서 여러 이미지/애니메이션 처리 ( 이미지마다 처리 ) 동시에 조금식 처리한다.
- Modular program structure (기능별로 분리하여 프로그래밍 가능)
  - 각 스레드 - 스레드 함수 분리

---

#### p. 20 Thread 시작 함수 작성법

1. for(){} loop 의해 동일한 **작업 반복**
   1. loop 내 => 반드시 대기하는 함수를 호출 시점
      - 주기적 실행 Time 대기 : sleep() EX) 10분마다 작업
      - 키보드, 마우스 대기 : scanf(), GetMessage()
      - 네트워크 대기 : recv(), recvfrom()
   2. 대기 함수에서 리턴 후 스레드가 담당하는 고유기능 다시 실행
   3. for 문 처음부터 반복

---

#### p. 22 Thread의 메모리 구조

- 스레드 마다 하나씩 
  - 컨트롤 블록
  - 스택을 가진다.

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008033918679.png" alt="image-20221008033918679" style="zoom:67%;" />

---

#### p23. Thread Structure(TCB) : 쓰레드가 가지고 있는 특징

- Thread: 스케줄링 대상

- Each thread has 
  - Thread Control Block(TCB)
    - 쓰래드의 실행 상태 : Running, Ready, Block, etc
    - 실행하지 않을때  쓰래드의 정보를 저장
    - 최근 정도 우선 순위 스케줄링.
  - execution stack: 지역변수의 스택
- 한 PS내의 모든 thread들은
  - 전역변수는 공유 : 메모리 한곳에만 존재
  - 지역변수들은 공유하지 않음
    - Thread 마다 => 지역변수들이 저장되는 별도 스택제공

---

#### p. 24 프로세스 요약

- 자원의 소유자 역할
  - **CPU를 할당하는 대상XXX**   <=> **대상은 스레드이다.**
  - 실행코드, 전역변수, 힙
  - 열려진 파일이나 소켓 등의 **자원 소유주**
  - PS 내의 모든 **Thread는** 위에 소개된 자원들 공유
    - <img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008101215406.png" alt="image-20221008101215406" style="zoom:50%;" />

---

#### p. 25 스레드 요약

- 스레드 : 실행자
  - Processor(CPU)를 할당하는 **대상, 스케줄링 대상**
  - main 스레드가 => 스레드 생성 함수를 => 호출
    - **여러 스레드**가 동일한 **시작함수**에서 실행을 시작가능.
  - **한 프로세스 내의 모든 스레드** -> PS의 함수들도 호출가능 -> 실행가능(실행 코드 공유)                                      -> **전역변수와 힙 공유(동시에 수정시 주의)**
  - TCB와 스택을 개별적 소유
    - 여러 스레드, 동일한 함수에 들어가 실행 => 함수 내의 지역변수 및 매개변수는 => 각스레드의 스택에 저장된다.



각 스레드당 => 스택 메모리 할당 => 지역변수 수정시 => 각자의 스레드 스택에 저장

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008103014301.png" alt="image-20221008103014301" style="zoom:67%;" />

---

#### p26 하나의 프로세스 내의 여러 스레드

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008104405316.png" alt="image-20221008104405316" style="zoom:67%;" />

- 운영체제 메모리에 할당  ||  소켓 정보 구조체 : Open file, Programing ofen

- 문맥 (context)

  - PC(Program counter) + SP(Stack Pointer) + General working registers

    Counter 다음번에 실행한 프로그램 주소

---

#### p. 27 지역변수(스택영역)와 전역변수(Data영역)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008104722224.png" alt="image-20221008104722224" style="zoom:67%;" />

---

#### p. 28 지역변수(스택영역)와 전역변수 (Data 영역)



<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008104829952.png" alt="image-20221008104829952" style="zoom:67%;" />

---

# chapter 7. Memory Management

#### p. 2 Memory Management

메모리 관리의 필요성

---

#### p. 4 Memory Management Requirements (메모리의 재배치)

- Relocation (재 배치)
  - 프로그램 실행 시 배치 -> 장소는 모른다 -> 비어있는곳 알고리즘에 의해 할당
  - Disk **swap out** 한 후 다시 **swap in** 할때
    1. 프로그램이 실행하는 동안
    2. swapped to disk 하면
    3. 디스크를 다른 장소에 배치된다.
  - Memory compaction 때 논리주소 -> 실제 주소 변환 필요

---

#### p. 6 Memory Management Requirements : 메모리 보호

- Protection(메모리 보호) : 다른 **메모리의 값의 침범 금지**
  - 다른 프로그램이 내 영역 침범 할 때 보호
  - mmu가 메모리 컨트롤, 체크하는 곳

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008110703171.png" alt="image-20221008110703171" style="zoom:50%;" />

---

#### p. 7 Memory Management Requirements : 메모리 공유

- Sharing( 메모리 공유 ) : 조심해야 한다.
  - 프로그램 코드 공유
    - 한세트 코드가 main에 있다.
    - 동일 프로그램이 여러 개 실행 -> 프로그램 **코드는 공유**, 프로그램 데이터는 따로 가짐
  - DLL 라이브러리 코드 공유
    - 서로 다른 여러 프로세스가 하나의 **DLL 코드 공유**

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008110739455.png" alt="image-20221008110739455" style="zoom:50%;" />

---

#### p. 8 Memory Management Requirements : Logical Organization? 논리 구성

- modules(소스파일?) 로 프로그램 작성가능

- Modules(소스파일) 작성과 컴파일 가능하다.

- 보호의 정도 수정가능 (read-only, execute-only 실행만 가능)

- **Share modules** among processes

  <img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221008111350091.png" alt="image-20221008111350091" style="zoom:50%;" />

---

#### p. 10 Memory Partitioning and Placement (분할, 배치)

- Fixed Partitioning
  - 고정 분할
  - 고정되있지 않는 분할
- Dynaming Partitioning
  - First-fit 알고리즘
  - Best-fit 알고리즘
  - Next-fit 알고리즘
  - Budd y sysetem



공평한 메모리 할당의 영역 vs 불공평하지 않는 메모리 할당의 영역

p. 11의 영역

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221011213229379.png" alt="image-20221011213229379" style="zoom:67%;" />

---

#### p. 12 Fixed Partitio

- Maing memory use is inefficient
  - 고정된 메모리 공간에 3M가 남는다.
  - 8M가 고정된 메모리에 3M가 할당되니 => 
  - internal 고정메모리 공간
  - internal fragmentation (단편화)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221011214017413.png" alt="image-20221011214017413" style="zoom:67%;" />

고정된 8M의 고정된메모리 관련된 => internal 고정 메모리 공간(단편화)

#### p. 13 Dynamic Partitioning 동적 할당

- 동적 재배치가 일어 날때 비어 있는 공간에 재배치.
- 동적인 재배치 -> external fragmentation(단편화)
- 중간중간 사용하지 않는 영역을 할당한다.

#### p. 14 The Effect of Dynamic Partitioning

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012055117249.png" alt="image-20221012055117249" style="zoom:67%;" />

---

#### p. 15 동적할당 알고리즘

1. Best-fit algorithm
   - 성능이 안좋다 => Fragment 생성 많다.
   - Compaction 빈번하게 일어난다.
   - 딱맞는 빈공간에 동적할당 실행
2. First-fit algorithm
   - 가장 첫번째공간에 할당
   - Simplest, Fastest and Best 가장 좋다, 효율이 높다.
3. Next-fit algorithm
   - 마지막 할당 위치에 처음으로 할당
   - First 보다 성능이 작게 , 안좋다

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012055804952.png" alt="image-20221012055804952" style="zoom:67%;" />

Best  2-1-3

first   1-2-3

next   3-3-1-2

worst 3-1-3-2

---

#### p. 19 버지 알고리즘 : 메모리 할당

- 메모리 할당은 2^x, 2의 지수승 크기로 할당
  - 40byte 요청 => 64byte 할당
  - 만약에 64크기의 빈 블록이 없다면 128byte => 64, 64byte로 분할한후 왼쪽 할당함
  - 128, 256, 512 크기의 빈 블록이 없다면 => 원하는 블록을 찾은후 -> 64을 찾을때 까지 계속 반으로 분할

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012061937998.png" alt="image-20221012061937998" style="zoom:67%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012062005692.png" alt="image-20221012062005692" style="zoom:67%;" />

---

#### p. 20 Buddy Algorithm : 메모리 반납

메모리 블록이 반납

buddy가 이미 free인지, 계속 사용 중인지 확인

- buddy가 블록이 free라면
  - 반납된 블록과 buddy블록을 하나로 합친다(메모리 합병, merging)
  - 합병된 큰 블록의 buddy가 free라면 합병과정을 계속 진행함

---

#### p. 21 Buddy Algorithm : 확인

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012062512120.png" alt="image-20221012062512120" style="zoom:50%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012062545163.png" alt="image-20221012062545163" style="zoom:67%;" />

100Km을 찾는다 -> 128k 있어? 있으면 찾아 : 없으면 *2의 공간 찾아 반복후

찾으면 128Km까지 분할 한다.



![image-20221012063007475](C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012063007475.png)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012062958419.png" alt="image-20221012062958419" style="zoom:67%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012063046011.png" alt="image-20221012063046011" style="zoom:50%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012063110470.png" alt="image-20221012063110470" style="zoom:67%;" />

---

#### p. 24 Addresses

- Logical address 논리주소 <==> 진짜 주소
- Relative address 상대 주소 <==> 논리 주소(맨처음을 기준으로, 논리주소)
  - 알려진 포인터로 부터 얼마나 떨어졌있는가?
- Physical address 진짜 주소(메모리의)
  - mmu장치만 알수 있다.(절대 주소는 MMU장치만 안다.)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012063838946.png" alt="image-20221012063838946" style="zoom:67%;" />

---

#### p. 25 Basic Paging System

exe(Memory)를 조각 내서 => 관리한다.

- small equal fixed - 4kb로 (고정으로) 쪼갠다.
- main memory의 frame에 넣는다, fram = page의 크기 비슷하다.
- main memory의 frame에 넣는다, fram의 크기와 page의 크기 같다.

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012064317273.png" alt="image-20221012064317273" style="zoom:67%;" />

---

#### p. 27 Assignment of Process Pages to Free Frames

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012064430069.png" alt="image-20221012064430069" style="zoom:80%;" />

---

####  p. 28 Assignment of Process Pages to Free Frames

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012064919258.png" alt="image-20221012064919258" style="zoom:67%;" />

---

#### p. 29 Page Tables for Example

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012065340045.png" alt="image-20221012065340045" style="zoom:67%;" />

page 번호와 할당된 frame 번호를 이용하여 

논리주소(가상주소) => 실제주로로 변환하는데 활용됨

---

#### p. 30 Logical-to-Physical Address Translation

page 번호 + offset  

MMU 장치에서 이러한 과정을 H/W적으로 자동실행

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012065547445.png" alt="image-20221012065547445" style="zoom:67%;" />

---

#### p. 31 Paging 주소 변환{1}: 논리주소=>실제주소

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012070158490.png" alt="image-20221012070158490" style="zoom:40%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012070256985.png" alt="image-20221012070256985" style="zoom:67%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012070317631.png" alt="image-20221012070317631" style="zoom:67%;" />

1026                              <=           2050

page = 1, ofset = 2                     frame = 2, ofset = 2

---

#### p. 32 Paging 주소 변환{2}: 실제주소 => 논리주소

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012071034028.png" alt="image-20221012071034028" style="zoom:67%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012071114069.png" alt="image-20221012071114069" style="zoom:67%;" />

---

#### p. 33 Paging 주소 변환{3}: 페이지 테이블 만들기

페이지 크기를 이용하여 frame 크기 알기

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012071440757.png" alt="image-20221012071440757" style="zoom:67%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012071504111.png" alt="image-20221012071504111" style="zoom:67%;" />

---

#### p. 34 Basic Segmentation System

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012083751294.png" alt="image-20221012083751294" style="zoom:50%;" />

- Segment
  - 코드, 전역변수, 힙, 스택 세그먼트(영역)
  - 세그먼트마다 길이가 다르다 =>  컴팩션 실행
    - dynamic partitioning compaction 필요
    - 실제 시스템에서 방법 사용하지 않음
  - 한 세그먼트가 가질 수 있는 최대 크기가 시스템 내에 정해짐

---

#### p. 35 Logical Addresses

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012084438376.png" alt="image-20221012084438376" style="zoom:67%;" />

---

#### p. 36 Logical-to-Physical Address Translation

Segment 가상 논리 => 실제 주소

컴퓨터에서 어떻게 ? 가상 논리 => 실제 주소로 변화는가

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012084523482.png" alt="image-20221012084523482" style="zoom:67%;" />

---

#### p. 37 Segmentation 주소 변환[1]: 논리주소 => 실제주소

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221012084821588.png" alt="image-20221012084821588" style="zoom:67%;" />

---



---

# chapter 08 Virtual Memory 중간

#### p. 2 Types of Memory , 메모리의 종류

- Real memory
  - Main memory
- Virtual memory
  - Real memory + memory on disk ( 메인 메모리 + ssd 의 부분) = virtual memory
  - 보다 많은 프로그램 실행 가능해 짐
  - 궁극적으로 CPU 이용률을 향상시킴

---

#### Real Memory (smart phone)

- 7장 내용
  - 프로세스 page or segmentation 단위로 분할
  - 프로세스 전체가 메모리에 있어야 실행가능
  - 프로세스가 메모리에 연속적으로 배치될 필요 없음
    - Page || segmentation 단위로 비연속적으로 배치
  - MMU 장치에서 HW적으로 주소 변환 : 논리주소 => 실제 주소
    - CPU는 논리 주소만을 취급
    - 프로세스 모든 포인터 변수 => 논리주소
    - 실제 주소는 MMU만 취급
  - MMU 역할
    - Memoru protection: 영역 침범 시 interrupt 걸어줌
      - page num을 보고 해당 page에 대한 침범 확인
      - page 번호가 없으면 => delete 시작
    - 논리주소 -> 실제주소 변환

---

#### p. 4 Virtual Memory (windows & UNIX)

- Real Memory의 기능 활용
  - Paging system || Segmentation system 사용
  - MMU 장치 : 논리주소 => 실제주소
  - 프로세스 메모리에 연속적으로 배치 안한다.
- 차이점
  - 프로세스의 일부분만 메모리에 로드 되어도 실행 가능
    - 나머지는 디스크에 : 필요할 때 메모리에서 가져온다.
    - 장시간 사용않하는 페이지는 swap out한다.
    - Disk swap out, swap in을 수행함

---

#### p. 5 Program Execution && Page Fault

1. 프로그램 실행
   - 프로그램 시작 (main 함수와 그 함수가 사용하는 지역변수, 전역변수)만 메모리 로드 후 실행
   - Resident set - 메모리에 로드된 프로그램 일부분
2. 메모리에 없는 주소를 참조 했을때
   - Page Fault(Memory fault) interrupt발생
   - Interrupt handler(인터럽트 처리 함수) 실행
     1. 실행 중이던 process -> Blocking state
     2. Issues a disk I/O Read request
     3. Calls scheduler: 다른 프로그램 찾아서 실행한다.
        - while the disk I/O takes place
     4. CPU는 다른 프로그램 실행 (프로그램 스위치)  => Block 상태

---

#### p. 6 Execution of a Program

3. disk가 프로그램(ps) 요청했던 부분을 읽고
   - Disk interrupt발생 및 interrupt handler 실행
     1. Update **page table** of the affected process
        - 메모리에 새로운 페이지가 추가
     2. Places the process in the **Ready state**
     3. Calls **scheduler**
     4. Page fault 발생했던 process **runs again**
