node을 잘 이해하기 위해서는 자바스크립트의 동시성 모델에 대해 잘 이해해야 합니다.

자바스크립트의 실행 모델은

event loop, call stack, calback queue 개념으로 이루어집니다.

---

**이벤트 루프** 모델은 여러 스레드를 사용합니다.

그 중 우리가 작성한 자바스크립트 코드가 실행되는 스레드를

메인 스레드라 부릅니다.

한 Node.js프로세스에서 메인 스레드는 하나이며, 한 순간에 한 줄씩만 실행

그러나 그 외의 일(file I/O, network ...) 파일 입출력, 네트워크 데이터 송신 등등

---

**콜 스택** 이란 지금 시점까지 불린 함수들의 스택입니다.
(콜 스택이란 밑에서 부터 하나하나식 쌓아서 위에서 부터 빼는 것이다.)
함수가 호출될 때 쌓이고, 리턴할 때 빠집니다.

이벤트 루프가 다음 콜백콜 처리하려면 지금 처리하고 있는 콜백의 실행이 완전히 끝나야 합니다.

처음들어온것이 나중에 나가는 형태

---

**Run-to-completion**

call stack이 완전히 빌 때까지 처리한다는 것과 동일합니다.

---

**call back queue** 처음들어온 것이 나중에 나가는 형태

콜백큐(메세지 큐)는 앞으로 실행할 콜백(함수와 그 인자)들을 쌓아두는 큐입니다.

콜백은 브라우저나 Node가 어떤 일이 발생하면(event) 메인 스레드에 이를 알려주기 위해(callback) 사용됩니다.

이벤트는 파일 처리의 완료, 네트워크 작업의 완료, 타이머 호출 등이 있습니다.

---

문제 1

```js
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");
```

어느순으로 출력이 될까요?

콜백큐에서 1,3 을 처리한후 콜백큐에 2을 집어넣습니다.

```
1
3
2
```

---

문제 2

```js
setInterval(() => {
  console.log("Hey!");
  while (true) {}
}, 1000);
```

이것은 면번을 반복할까요? 저는 5번을 생각했는데

```
Hey!
```

한번입니다 while(true)을 리턴하지 않았기 때문에

이 동안은 calback queue에서 콜백을 꺼낼 수가 없기 때문에,

setInterval이 아무리 콜백을 쌓아도 메인 스레드에서

실행될수가 없습니다.

이런 경우를 **event loop를 block**한다고 합니다.

---

## non-blocking I/O & offloading

```js
// 여기서 Node에게 파일을 읽어달라고 요청하고,
// 워커 스레드에서 파일을 읽기 시작합니다.
fs.readFile(fileName, (err, data) => {
  // Node가 파일을 다 읽고 나면
  // 1. callback queue에 이 함수에 err, data 인자를 채워서 넣고
  // 2. callback queue 에서 꺼내질 때 이 부분이 실행됩니다.
});

// readFile의 호출이 끝난 직후 바로 이 함수를 실행하게 됩니다.
// 이는 여전히 같은 콜백을 처리하는 중이기 때문입니다.
someTask();
```

브라우저나 Node.js에서나, Web API 혹은 Node API의 동작이 끝나면 callback queue에 등록합니다.

브라우저나 Node가 요청 받은 일을 하고 있는 동안

메인 스레드와 이벤트 루프는 영향을 받지 않고

계속 실행 됩니다.

이를 **offloading**이라고 하며, **Node 서버의 메인 스레드가 하나임에도 불구하고 빠르게 동작할 수 있는** 이유입니다.
