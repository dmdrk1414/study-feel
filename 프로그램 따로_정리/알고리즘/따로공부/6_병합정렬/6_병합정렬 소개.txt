시작하기 전)

지난번 포스팅까지 해서 Recursion 에 대해 깊이 공부했습니다. 그래서 꽤 순환적 사고방식에 익숙해진 것 같습니다. 앞으로도 Recursion 방식을 계속 사용할 것이기 때문에 굉장히 의미있었다고 생각하고, 뿌듯합니다 ~* 이제부터는 '정렬' 에 대해서 자세히 공부할 것 입니다. 정렬이라는 것은 간단히 생각하면 굉장히 쉽게 구현할 수 있습니다. 대표적으로 '버블정렬' 같은 것들이 있지요. 하지만 인간은 이에 그치지 않고 '어떻게 하면 더 빠른 정렬을 할 수 있을까' 에서 출발하여 많은 정렬방법을 연구하고, 개발해왔습니다. 이번 시간부터 그러한 정렬들에 대해 원리를 탐구해보고, 구현해볼 것 입니다. 포스팅에 첫 시작은 ! '합병정렬' 입니다. 시작하겠습니다!

 


합병정렬(merge sort) - 원리)

합병정렬의 기본적인 전략은 '분할정복법' 입니다. 분할정복법을 사용한 합병정렬에 알고리즘 단계는 크게 3단계로 나눠집니다.

1. 분할 : 해결하고자 하는 문제를 작은 크기의 동일한 문제들로 분할

2. 정복 : 각각의 작은 문제를 순환적(Recursion)으로 해결

3. ***합병*** : 작은 문제의 해를 합하여(merge) 원래 문제에 대한 해를 구함

이렇게 3단계를 통해 기존의 '버블정렬' 보다는 훨씬 효율적으로 정렬할 수 있습니다. 사진으로 이해해봅시다.

 



- 강의 中 사진 참고 -

 

먼저 데이터를 분할합니다. 그렇게 Recursion으로 반복하다보면 크기가 1인 리스트들이 남게 됩니다. 이제 핵심인 merge 작업을 합니다. 중요한 것은 데이터들을 합치면서 정렬작업을 같이한다는 것입니다. 그렇게 Recursion이 되돌아올 때 merge 작업을 한다면, 사진과 같이 최종적으로 돌아왔을 때 완전히 정렬되게 됩니다. 전체적인 알고리즘을 알았으니 이제 세부적으로 들어가보겠습니다. 이제 merge 작업을 어떻게 할 것이냐는 문제만 남았습니다. 사진에서 2번째 줄을 예시로 합쳐보겠습니다.

 

과정 1



분할된 두 구역(두 구역은 각각 정렬되어있음)을 한 구역으로 합쳐보겠습니다. 이 작업을 하기 위해 하나의 배열을 더 만들어야 합니다. 여기서 두 구역 중 첫 번째 구역에 시작을 p , 끝 값을 q 라 가정하고, 두 번째 구역에 시작을 q+1 , 끝을 r 이라고 가정하겠습니다. 이제 p번째 배열에 값과 q+1번째 배열에 값을 비교한 후, p번째 값이 더 크므로, q+1번째 값을 새로운 배열로 보내줍니다. 그리고 q+1칸을 한 칸 증가시켜줍니다.(q+1 값은 이제 볼 필요 x)

 

과정 2



과정 1을 마치면 이렇게 그림이 그려집니다. 앞서 말했듯이 q+1번째 값은 이제 볼 필요 없으니까 한 칸 증가 시켜줍니다. 다음으로 p번째 값과 q+2번째 값을 비교해줍니다. 값이 같으므로 어떤 구역 값을 이동시켜도 상관없습니다. 같을 때는 왼쪽 칸을 옮기기로 정의하죠ㅋㅎ 이 과정을 계속 반복합니다.

 

과정 3



두 구역 중 한 구역이라도 칸을 넘어버리면 반복을 종료하고 남은 부분을 새 배열에 넣는 반복문을 돌립니다. 이렇게 새 배열이 완성되면 원래 배열에 그대로 p 에서 r 까지의 값을 붙여넣습니다. 이렇게 하면 완벽하게 merge 작업이 해결됩니다 ~* 이제 코드로 보여드리겠습니다.

 

합병정렬(merge sort) - 구현)

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
#include <stdio.h>
void mergeSort(int data[], int p, int r);
void merge(int data[], int p, int q, int r);
int main() {
     int data[8] = {5,2,4,7,1,3,2,6} , i;
     printf("정렬 전\n");    
     for(i = 0; i < 8; i++) {
         printf("%d ", data[i]);
     }
     mergeSort(data, 0, 7);
     printf("\n정렬 후\n");
     for(i = 0; i < 8; i++) {
         printf("%d ", data[i]);
     }
  return 0;
}
void mergeSort(int data[], int p, int r) {
    int q;
    if(p<r) {
        q = (p+r)/2;
        mergeSort(data, p , q);
        mergeSort(data, q+1, r);
        merge(data, p, q, r);
    }
}
void merge(int data[], int p, int q, int r) {
    int i = p, j = q+1, k = p;
    int tmp[8]; // 새 배열
    while(i<=q && j<=r) {
        if(data[i] <= data[j]) tmp[k++] = data[i++];
        else tmp[k++] = data[j++];
    }
    while(i<=q) tmp[k++] = data[i++];
    while(j<=r) tmp[k++] = data[j++];
    for(int a = p; a<=r; a++) data[a] = tmp[a];