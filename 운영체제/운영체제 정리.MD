## chapter 2. Operating System

#### p 2. 운영체제 시스템 : 어플 과 하드웨어의 중간 다리역활

---

#### p 3. 운영체제의 목적

1. 편리성
2. 효율성 : 자원에 대한 효율성
3. 발전성 : 기본 베이스 제공

---

#### p 5. - 6 운영체제의 편리성 : 편리성을 주는 기능들 1 - 6;

1. Program development
2. Program execution
3. Access to I/O devices
4. Controlled access to files
5. System access
6. Accounting
7. Error detection and response



1. 프로그램 계발을 해준다 
2. 프로그램 실행과정, 자원관리, 스케줄링 
3. 복잡한 내부 숨기고 함수만 호출 (I/O devices 접근)
4. 여러 장치, 사용자 동시 접근(파일 동시 접근)
5. 다중사용자(자원보호, 동시성): 동일한 시스템
6. 회계기능 : 매래 각디바이스 성능 향상 (성능 개선의 여지)
7. 에러 검출 알려주는 기능 : 블루 스크린, 덧셈 뺏셈, 0으로 나눔,메모리 할당 금지

---

#### p 7. 자원의 효율적 사용

1. Resources 컴퓨터의 자원 -> 메모리 컴팩션 ( 효율적 관리 )
2. Responsible for managing resources 자원의 책임
3. Functions in the same way 함수들의 집합 Collective of Fuc

---

#### p 8.  컴퓨터의 전체적인 사진.

<img src="I:\Documents\Desktop\운영체제\1@attach_221006_183716_938.jpg" style="zoom:40%;" />

---

#### p 9. 

- OS의 이점 발전성 (컴퓨터의 발전이 쉽게이뤄진다)
- 발전성 -> 고치면서 커진다.
- 새로운 하드 -> 새로운 기능
- 패치 프로그램 기존 운영 체제 모듈중 에러가 있는 모듈 제거 -> 새로운 모듈 삽입

---

#### p 10. Operating System

운영체제의구성 OS = Kernel + System Programs

---

#### p 11. Kernel 커널

커널  

- 거대한 API 함수 관련 함수들의 집합
- 거대한 API 함수 관련 함수들의 집합
  - 프로그램 호출 실행
  - 디바이스(네트워크, USB카드 드라이버, 타이머)
  - 데이타 -> 하드웨어 -> CPU -> 디바이스 드라이버

함수들을 크게 나누어 보면 

- Process관리, 스케줄링, 실 기억장치, I/O device 드라이브

- kernel 함수들이 호출되는가?

  - 응용프로그램에서 API 함수를 호출할 경우
  - I/O (CPU에서 전기적) 장치에서 데이터가 들어올 경우 

  ---

#### p 13. Multiprogramming Systems

멀티 프로그래밍

1. I/O 함수 실행시 A -> B
2. I/O 장치에 데이터가 들어 올때 A -> B 우선순위에 따라 다르다
3. 현제 프로그램 종료 A -> B
4. 시분할 처리 기능 X



- 여러 프로그램을 동시에 실행시킴

- CPU는 언제  다른 프로그램에게 넘기는가?  A -> B -> c 

  - 실행중 A 프로그램 ->  I/O함수 (scanf) 호출할때 (장치에 데이터가 없을때) -> A -> B
  - I/O 장치에 A가 데이터가 들어오면 Ready상태가 된다. ( 우선순위에 따라 A실행 상태 여부확인가능)
  - 현재 실행중 프로그램이 종료 OR I/O 장치로 인해 대기중이면 다른 프로그램에 CPU 넘어감

- 시분할 처리 기능 없음

  ---

#### p 19. Time Sharing System 시분할 시스템

1. CPU가 일정시간 동안 번가라 실행

   1. 현제 실행 프로그램이 I/O함수 호출할때
   2. I/O 데이터 받을때
   3. 0.1초식 번가라 사용 (쉐어링)

   

1. CPU가 각 프로그램을 일정시간동안 번갈아 가면서 실행
2. 언제 CPU를 다른 프로그램에 넘기는다
   1. I/O함수 호출
   2. I/O장치에 데이터가 들어올때
   3. 현제 실행중 프로그램 0.1초동안 I/O없이 실행할때 쉐어링

---

#### p 20. Multiprogramming vs Time Sharing

|         ---         | Batch Multiprogramming 멀티 프로그래밍 |    Time Sharing 타임 쉐어링     |
| :-----------------: | :------------------------------------: | :-----------------------------: |
| Principal objective |     Maximize processor use 이용률      | Minimize response time 반응시간 |
|      반응시간       |                  낮다                  |              높다               |
|       이용률        |                  높다                  |              낮다               |

- CPU 이용률 : CPU가 총실행한 시간 중 프로그램 실행시간

  - **사용자 프로그램실행(7초)** + [ CPU스위칭(0.6초) + IO스위칭(0.4초) ] + CPU휴식상태(2초)

    ​							                                  CPU 시간 버림                              정기적 신호가 올때 까지 for문 반복

    - CPU 이용률은 0.7 = 7초 / 10초

- 응답시간(response time) : 입력이후 첫 출력이 나오는 시간
  1. 키보드에서 입력후 , 처음으로 화면에 출력이 나오는 시간
  2. Internet 에서 주로 입력후 웹페이지가 화면에 보여지는 데 걸린 시간
  3. 프로그램의 응답시간 ex) 프린터의 시간.

---

p 22. Multi & Time 시간 계산

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221006224254161.png" alt="image-20221006224254161" style="zoom:70%;" />

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221006224123535.png" alt="image-20221006224123535" style="zoom:70%;" />

- 멀티 프로그램
  - ( 1초 * 9개 프로그램 ) + 0.1초 = 9.1초 이후 내꺼 프로그램 response 시간
- 타임 쉐어링
  - (0.1초 * 9개 프로그램) + 0.1초 = 1초 이후 내꺼 response time

---

#### p. 23 멀티프로그램 vs 타임 쉐어링 CPU 이용율 비교

- 타임 쉐어링   **이용율 낮음 VS 응답율 높음**

  - 0.1 마다 프로그램 번가라 실행

  - 이용율 = 사용자프로그램실행(10초) + CPU스위칭(0.4초) + IO스위칭(0.1초)

    CPU 이용률은 0.95 = 10초 / 총 10.5초			95%
    
    

- 멀티 프로그램   **이용율 높음 VS 응답율 낮음**

  - I/O작업이 아니면 계속 진행

  - 이용율 = 사용자프로그램실행(10초) + IO스위칭(0.1초)

    CPU 이용률은 0.99 = 10초 / 총 10.1초             99%

---

#  chapter 3. Process Description and Control

#### p. 2 현제 돌고있는 프로그램

#### p. 3 Process 생성법

1. Interactive logon : 로그인 할때
2. 기존에 실행된 Process에 의해서 = 기존에 실행된 Process에의해서 PS 실행

#### p. 4 Process Termination 프로그램 종료

1. Normal completion : Main 함수 리턴, EXIT 함수 Call.

2. Bounds violation : 포인터 실패 할때 / 경계 위반하는 경우 / Pointer 참조 실패.

3. Arithmetic error : 수학적 오류, 계산, '0'으로 나눌때.

4. Invalid instruction : 잘못된 명령어, 실행 파일 다운 -> 중간 실패 -> 실행파일 짤린다.

5. Parent termination : 부모 프로그램 종료 -> 자식 죽는다.

---

#### p. 6 Process Control Block (PCB)

PCB: 운영체제 내에서 관리 되는 프로세스 구조체 -> 프로그램의 정보

- 커널에 하나의 프로세스를 관리하는데 필요한 정보 보간

현제 돌고 있는 PS의 정보

- 시간

- 현제 돌고 있는 프로그램의 구조체
- 정보들을 가지는 Id

---

#### p. 7 process 구조체

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221006235556854.png" alt="image-20221006235556854" style="zoom:67%;" />

---

#### p. 8 Trace of Process

Dispatcher : 다른 프로그램으로 넘겨주는 것

Scheduler : Kernel 내의 하나의 함수 이름

- process중 우선순위가 가장 높은 프로세스 고른다.
- process에게 processor(CPU)를 넘겨주는 것.
- Scheduling 알고리즘 : 우선순위가 높은것 고른다.

---

p. 9 스케쥴러 Example

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007000101808.png" alt="image-20221007000101808" style="zoom:67%;" />

Program Counter : CPU가 실행할 다음 명령어 주소를                                                  								  가지는 레지스터 이름

---

#### p. 11 Scheduler의 실행 상태

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007000430179.png" alt="image-20221007000430179" style="zoom:67%;" />

각 프로그램 종료후 Scheduler 실행

---

#### p. 12 Process States 프로그램 상태

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007081852461.png" alt="image-20221007081852461" style="zoom:67%;" />

- A -> Dispatcher -> B -> Dispatcher -> C -> Dispatcher -> A -> Dispatcher -> C
- 많이 기다리면 우선순위 높다.

---

#### p. 13 프로그램의 5가지 영역

 A Five-State Model

1. Running : processor에 의해 실행중 상태
2. Ready : processor만 주어지면 언제든 실행될 수 있는 상태
3. Blocked : I/O장치에서 대기(waiting) 상태

----

#### p. 14 언제 상태가 변하나?? (프로그램의 실행 순서)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007082313545.png" alt="image-20221007082313545" style="zoom:67%;" />

- 한글 -> Block -> "ㄱ" -> Read -> run -> ㄱ 출력 -> Block -> "ㅏ" -> Read -> run -> ㄱ지우고 ->  가 출력 -> Block -> "ㄱ" -> Read -> run -> 가지우고 -> 각 출력 -> Block -> 저장 -> Read -> run -> Buffer -> 디스크에 저장 -> Block
- 마우스 -> Block -> 옮긴다 -> Read -> run -> 위치 이동 -> Block(반복) 

---

#### p. 15 언제 Wait(Blocking) 사태가 되는가

| -Device        | Wait, I/O함수 호출할때 Blocked 상태                          | I/O intrerrupt 발생시 Ready State됨              | Interrupt 종류                          |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------ | --------------------------------------- |
| 마우스, 키보드 | scnaf() 호출할때, GetMessage()호출할때                       | 키보드에서 엔터, 마우스를 움직일때               | 키보드 마우스 Interrupt                 |
| Disk(파일읽기) | read(), fread(),fscanf()                                     | 디스크가 파일을 읽고, 메모리에 전달한 후         | Dist(or USB) interrupt                  |
| 네트워크       | receive() 호출                                               | 네트워크 보드에 데이터 도착                      | Network interrupt                       |
| Timer          | Sleep(2000), sleep(2)                                        | 지정시간 (2초)이 지난후,                         | Timer interrupt                         |
| Samaphore      | lock(s) 함수 호출 때: 자원혼자사용할려고 lock 호출했지만 누가 이미 lock한 경우 | 다른 PS가 unlock(s) 함수를 호출, Lock을 풀어줄때 | Interrupt와 무관, unlock(s)호출할 때만. |

---

#### p. 16 Running -> Blocked 상태로의 전환

I/O함수 호출 : scnaf(), read(), receive()등

- API 함수 호출 -> kernel 속으로 진입
- 키보드, 디스크, 네트워크 device에 도착한 데이터가 도착할때 까지 대기
- Running 상태에서 Blocked 상태로 설정
- Scheduler() 함수 호출 -> processor를 다른 PS에거 준다 -> PS는 중단되고(대기) -> 다른  PS가 실행
  - Scheduler()함수 
    - Ready살태의 PS들 중 우선순위가 높은 PS고르고
    - processor(CPU)를 그 PS에게 넘겨줌
    - 선택할 PS가없으면 Processor는 idle 상태(for(;;); 를 무한 Loop 돌면서 생하면서 대기함)
    - Blocked 상태의 PS은 스케줄링 대상 제외

---

#### p. 17 Blocked -> Ready 상태로의 전환

- Block에서 Ready상태로 변환되는 과정

- 디바이스는 데이터가 도착한 것을 processor에게 interrupt(전기적 신호가 감)를 통해 통보함

- Interrupt(timer, network, disk 등으로 부터)이 오면

  1. Processor는 현제 process의 실행을 Block으로 (Running -> Ready)

  2. 대기큐에서 방금 들어온 데이터를 기다리는 process를 찾아 데이터 전달

  3. 데이터를 받은 PS을 Blocked 상태에서 Ready 상태로 변환
  4. Ready상태의 PS가 하나 추가 되어서, (PS가 우선순위가 제일 높을 수 있다) -> Scheduler()함수 실행

- Scheduler()를 호출 (Interrupt의 마지막에 항상 scheduler 호출함)

  1. 우선순위가 높은 PS에게 CUP를 넘겨 줌
  2. 프로세스가 우선순위가 제일 높으면 깨어난 프로세스가 바로 실행, interrupt가 들어오기 전에 실행된 프로세스가 계속 실행됨

---

#### p. 18 Multiple Blocked Queues

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007204641712.png" alt="image-20221007204641712" style="zoom:67%;" />

장치에 따라서 대기큐가 다르다.

---

#### p. 19 구조체 정보를 Queue(Linked List)을 이용해 구현함

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007205107310.png" alt="image-20221007205107310" style="zoom:67%;" />

---

### p. 20 Ready Queue or Blocked Queue?

- Queue는 process 구조체들을 linked list로 관리
- Ready Queue
  - Ready 상태의 process 구조체들만 모아 둔 linked list로 구현된 큐
- Blocked(Waiting or Event) Queue
  - 키보드 대기큐, 디스크 대기큐, 네트웤큐, 다이머 대기큐, 메마포어 대기큐 등이 있음

---

#### p. 21 Suspended Processes

만약 (if) main 하나로 90개의 프로그램 관리한다면? -> block (메모리 잡아 먹는다)

- 모든 PS가 I/O를 대기하고, CPU(processor)는 idle(놀고있는 상태)
- 장시간 대기 상태 -> PS를 Disk의 별도의 swap영역으로 빼낸다.
- swap out : disk로 ps를 뺀다.   memory -> disk
- swap in : memory로 ps을 넣는다. disk -> memory
- swap out하면, process는 Blocked -> Suspend state로 변경.
- swap in 하면, process는 suspend state -> Ready state로 됨.

---

p. 22 One Suspend State

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007212039886.png" alt="image-20221007212039886" style="zoom:67%;" />

Swap in 하면 : Suspend -> Ready 

Swap out 하면 : Bolcked -> Suspend

---

#### p. 23 Process Structure : 

시험, PS가 메모리에 어떻게 저장되는가?, stack에 저장된건?, 이중 저장되어있는건?

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007212620102.png" alt="image-20221007212620102" style="zoom:67%;" />

Stack 

1. 함수의 매개변수, 지역변수
2. 함수가 리턴해야 할 주소다.

Heap

1. 동적으로 할당 받음 (new)키워드 생성

Data

1. BSS 초기화 되지 않는 전역변수 | Data:  초기화 된 전역변수

text(code)

1. 함수 코드들 변수들을 뺀 실행코드 영역

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007213252359.png" alt="image-20221007213252359" style="zoom:70%;" />

---

#### p. 24 Process image & Process Control Block

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007213423415.png" alt="image-20221007213423415" style="zoom:67%;" />

stack 

1. 지역변수, 함수의 리턴할 주소를 

비어있는 공간

1. stack or heap이 부족할때 사용한다.

heap

1. new, 말록, 동적 할당 메모리 영역.

uninitialized data

1. bss : 초기화 하지 않은 전역변수.

initialized data

1. data : 초기화 된 전역 변수.

text(code) 

1. 함수 코드들, 변수를 뺀 실행코드 영역.

exe 파일 영역 : initialized data + test(code)

---

#### p. 25 Process Control Block = Process Structure : PS의 정보를 저장하는 구조체

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007214112987.png" alt="image-20221007214112987" style="zoom:50%;" />

Process Structure라고도 함 : PS의 정보 저장하는 구조체

1. Process Identification : ID 저장
2. Processor State Information : CPU 부분 백업 받는 부분, 컨테스트 저장(일시정지할때)
3. Process Control : 우선순위 등등 스케줄링 부분에서 사용하는 정보.

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007214607588.png" alt="image-20221007214607588" style="zoom:50%;" />

---

#### p. 27 Process Control Block : 문맥(context) data 문맥 저장

Processor State Information : context(문맥) data 문맥을 저장한다.

- context : CPU의 중간에 일시정지된 CPU를 저장하는 곳 | 
  - 실행중인 프로세스가 일시 중지 ->  processor의 registers(context data)전부를 백업하는 곳
  - 재실행 하면 -> 백업된 context data를 다시 CPU 내부로 download해야함                                          (memory -> processor registers)
- General Working Registers (R1, R2, R3)

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007215800878.png" alt="image-20221007215800878" style="zoom:50%;" />

if 실행하는 중간이 0.1초 가 끝나면?

- Process Control Block에 저장한다. -> context(문맥) data registers(context data)

---

#### p. 30 Process Control Block가 어떻게 CPU 레지스터를 저장하는가.

Processor State Information : context data(저장소)

- processor의 registers(context data)의 SP(stack point)
  - processor의 registers(context data)마다 SP가 있다.
  - SP는 
    1. function parameters, 함수 매개변수
    2. local variables 지역 변수
    3. address to return 리턴 값 

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007221018275.png" alt="image-20221007221018275" style="zoom:50%;" />

---

#### p. 31 Process Control Block : 안의 상세 정보

Process Control Information Ready 큐에서 기다리는 시간. 메모리를 실행하는 시간.

Process state : 프로그램의 상태 정보를 저장한다.

Priority : 우선 순의.

Scheduling-related information : waiting, amount of time that the process

Event: event 의 정보를 저장한다.

---

#### p. 32 Process Control Block :  PCB의 주된 기능

- A process may be linked : 다양한 링크드 리스트 저장
- ready or waiting queue : 상태저장
- parent-child (creator-created) relationship : 부모 자식관계

---

#### p. 33 

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007224812514.png" alt="image-20221007224812514" style="zoom:67%;" />



---

#### p. 34 Process Control Block : 프로그램의 Main memory가 어디에 있는가?

<img src="C:\Users\Park-Seung-Chan\AppData\Roaming\Typora\typora-user-images\image-20221007224515912.png" alt="image-20221007224515912" style="zoom:67%;" />

- 프로그램의 pointers to segment and/or page tables
  - pointers to structures of opened files, sockets, or windows(각각윈도우의 정보)
  - 파일 열때 정보 구조체 (ReadOnly, WriteOnly)

---

#### p. 35



---





---





---





----





---





---





---



